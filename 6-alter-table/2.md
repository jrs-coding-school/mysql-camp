# Exercise: Adding a Column as the Primary Key

Let’s add another column this time to our table.  We need a way to avoid confusion between individuals.  In other words, we need the unique rows in the table. Using a data type of `INT` is helpful because it will store simple integer values.  With integers, there isn’t a fractional part.  We don’t want negative numbers and we must provide a value when INSERTing rows into the table.  We want the database to provide the value when adding rows into the table; we would like for the database to figure that out for us.  We also need for the column to be indexed to help speed retrieval of the rows when we want to look up rock stars or join the table with other tables to retrieve rows from more than one table.

That’s a lot for a single column to do, but we can do it by adding a new column with the following data type and options:

- We will call the column **ID** and the data type will be `INT`.  This will hold an integer value.  
- We will add the `UNSIGNED` column attribute to the new **ID** column.  This will prevent negative values in the column.
- We will add the `NOT NULL` column attribute which will prevent missing values in the column
- We will add the  `AUTO_INCREMENT` option.   This will tell the database server to generate unique numbers to identify each row in the table.   It will generate sequential numbers automatically.  Pretty cool!  
-	The column must be indexed.  We will take care of this next by adding a primary key clause which indicates the column is indexed to allow fast lookups.  It also sets up a constraint on the table which dictates that each value must be _unique_.   This prevents us from entering the same **ID** value twice in the table.  

> Note:  There can only be one column in each table that uses the `AUTO_INCREMENT` column attribute. The column cannot have a `NULL` value.  We took care of this when we assigned the `NOT NULL` column attribute.  

0. Now let’s add the **ID** column by using the `ADD` action once again.  This time we will issue an `ALTER TABLE` command on the **Individual** table to add a column named **ID** which is unsigned meaning it won’t accept negative numbers.  We also specify that the column should not accept missing values and the value in the column will auto increment.  We will finish the column off by marking it as the primary key which adds an index to speed performance and a unique constraint to keep out duplicates:

```
mysql> ALTER TABLE Individual ADD ID INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY;
```

0.	By adding the `AUTO_INCREMENT` option on the column, the system will auto fill the column starting with a value of 1 and increasing the value by 1 for each existing row in the table.  Enter a `SELECT` statement to retrieve the data back out of the **Individual** table.

```
mysql> SELECT * FROM Individual;
```

0.	Add a couple more records (rows) into the **Individual** table. We will add a row for Neil Young and another row for Levon Helm.  But this time we will provide a value of `100` for the ID for Neil and a value of NULL for the ID for Levon.  Oh, I forgot to mention that Levon has passed away, so you will need to provide a value for the **DeceasedDate**.  How do you think the system will react to the value of 100 being placed for the **ID** column when it has `AUTO_INCREMENT` defined?  And what about the `NULL` value for the **ID** for Levon?  Do you think we will receive an error from the database server?  

```
mysql> INSERT INTO RockStar.Individual (ID, LastName, FirstName, BirthDate) VALUES (100, ‘Young’, ‘Neil’, ‘1945-11-12’);

mysql> INSERT INTO RockStar.Individual (ID, LastName, FirstName, BirthDate, DeceasedDate) VALUES (NULL, ‘Helm, ‘Levon’, ‘1940-05-26’,’2012-04-19’);
```

Did the database complain?

0.	And finally, use a `SELECT` statement to view the contents of the table.  What data did you find for Neil and Levon?  How about the **ID** column.
